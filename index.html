<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>墨菲定律</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这是我的小窝">
<meta property="og:type" content="website">
<meta property="og:title" content="墨菲定律">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="墨菲定律">
<meta property="og:description" content="这是我的小窝">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="墨菲定律">
<meta name="twitter:description" content="这是我的小窝">
  
    <link rel="alternative" href="/atom.xml" title="墨菲定律" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://avatars0.githubusercontent.com/u/20942996?v=3&amp;u=b3994d461fbfae56b624acf51a2fde58e0867f32&amp;s=400" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">七月</a></h1>
		</hgroup>

		
		<p class="header-subtitle">提莫队长正在待命</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/wangqianqian00" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">七月</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://avatars0.githubusercontent.com/u/20942996?v=3&amp;u=b3994d461fbfae56b624acf51a2fde58e0867f32&amp;s=400" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">七月</h1>
			</hgroup>
			
			<p class="header-subtitle">提莫队长正在待命</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wangqianqian00" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-wqq" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/14/wqq/">网页瀑布流效果实现的几种方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="几种常用的瀑布流介绍"><a href="#几种常用的瀑布流介绍" class="headerlink" title="几种常用的瀑布流介绍"></a>几种常用的瀑布流介绍</h2><p>一般瀑布流的实现常见有三种方式</p>
<ul>
<li><p>传统的多列浮动</p>
</li>
<li><p>css3样式定义</p>
</li>
<li><p>js计算绝对布局</p>
</li>
</ul>
<h4 id="传统的多列浮动简介"><a href="#传统的多列浮动简介" class="headerlink" title="传统的多列浮动简介"></a>传统的多列浮动简介</h4><p>首先固定屏幕中展示的列数，每一列中间的数据作为一组单独计算，插入数据时分别插入不同列中</p>
<p>优点:</p>
<ul>
<li>布局最为简单,一般只依赖与一个浮动布局</li>
<li>不需要知道内容的高度，所以当有图片未加载时也不影响</li>
</ul>
<p>缺点:</p>
<ul>
<li>只适用于特定的屏幕，当屏幕size变化时，无法动态实现列数的更改</li>
<li>拓展不易</li>
</ul>
<h4 id="css3样式定义瀑布流简介"><a href="#css3样式定义瀑布流简介" class="headerlink" title="css3样式定义瀑布流简介"></a>css3样式定义瀑布流简介</h4><p>利用css3中特有属性，在高级浏览器中实现瀑布流效果</p>
<p>优点:</p>
<ul>
<li>直接使用css样式，最为简洁，不依赖于任何js</li>
<li>拓展方便，直接往容器内部添加内容即可</li>
<li>自适应，屏幕变化，布局也会变化</li>
<li>当各个item的宽度不一致时，这种方式也适用</li>
<li>像一些特殊的如固定的两列瀑布流也可以很方便实现(固定显示两列，每一列可以横着有多个item)</li>
</ul>
<p>缺点:</p>
<ul>
<li>需要高级浏览器支持(其实这个现在已经不算缺点了)</li>
<li>这种方式和普通瀑布流的原理有区别，不是分别往不同列中插入数据，而是先往一列中插入数据，达到一定高度后再往其它列中插入数据，有时候用这种方式会达不到预期效果(这个是比较关键的，这种方式有时候体验达不到预期)</li>
</ul>
<h4 id="js计算绝对布局实现瀑布流简介"><a href="#js计算绝对布局实现瀑布流简介" class="headerlink" title="js计算绝对布局实现瀑布流简介"></a>js计算绝对布局实现瀑布流简介</h4><p>利用js，动态计算元素的插入位置，利用绝对布局absolute进行定位，根据屏幕的不同可以动态调整</p>
<p>优点:</p>
<ul>
<li>便于拓展，方便数据的添加</li>
<li>自适应，屏幕变化，布局也会变化</li>
</ul>
<p>缺点:</p>
<ul>
<li>计算时需要知道内容高度，如果包含图片，需要等图片加载完毕再计算，否则会存在误差</li>
<li>各个item的宽度需要一致</li>
</ul>
<p>就实用性而言，传统的瀑布流比较适合业务场景较为单一的情况，比如手机中固定两列的情况，css3瀑布流布局由于有时候会造成一些不理想的局面，所以更多的被用在了面试题等上面，最后那张绝对布局的瀑布流方式是被应用的最为广泛的</p>
<p>本文主要探讨css3瀑布流和绝对定位瀑布流的实现</p>
<h3 id="css3瀑布流的实现"><a href="#css3瀑布流的实现" class="headerlink" title="css3瀑布流的实现"></a>css3瀑布流的实现</h3><p>这种实现方式是最为简单的，仅仅是基于css3的新属性(column-width或column-count)</p>
<pre><code>css3中增加了一个新的属性：column，来实现等高的列的布局效果。该属性有column-width宽度，column-count数量等，并且能根据窗口自适应。
</code></pre><p>css实现瀑布流分为两种效果，普通横向瀑布流与固定列数的瀑布流</p>
<h4 id="普通横向瀑布流"><a href="#普通横向瀑布流" class="headerlink" title="普通横向瀑布流"></a>普通横向瀑布流</h4><p>这种瀑布流方式常常用于和js绝对布局方式比较，但是虽然从显示上来说，效果差不多，但是从用户体验的角度讲，这个不符合平常的习惯，以下是两种方式的效果图对比</p>
<p><img src="http://a3.qpic.cn/psb?/V12Zwqs81gGyHH/GU4WHdlJAj.d4N72rTLU0zMxMEGCctPUH3YMcRCrwuw!/b/dAoBAAAAAAAA&amp;bo=4AR7AwAAAAAFAL8!&amp;rf=viewer_4" alt="Mou icon"></p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code>.container{
    /*宽*/
    -webkit-column-width:200px;
    -moz-column-width:200px;
    -o-colum-width:200px;
    /*间距*/
    -webkit-column-gap:1px;
    -moz-column-gap:1px;
    -o-column-gap:1px;
}
</code></pre><h3 id="固定列数的瀑布流"><a href="#固定列数的瀑布流" class="headerlink" title="固定列数的瀑布流"></a>固定列数的瀑布流</h3><p>这种布局用到比较少<br><img src="http://a2.qpic.cn/psb?/V12Zwqs81gGyHH/oMEH3MeC3gemR8TAI6S8N8pFjZYcKcO.Fu8YGbOoNk0!/b/dAkBAAAAAAAA&amp;bo=5QJPAgAAAAAFAIk!&amp;rf=viewer_4" alt="Mou icon"></p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code>.container{
    /*固定列*/
    /*-moz-column-count:2; 
    -webkit-column-count:2; 
    column-count:2;*/
    /*间距*/
    -webkit-column-gap:1px;
    -moz-column-gap:1px;
    -o-column-gap:1px;
}
</code></pre><h3 id="js绝对布局瀑布流实现"><a href="#js绝对布局瀑布流实现" class="headerlink" title="js绝对布局瀑布流实现"></a>js绝对布局瀑布流实现</h3><p>这种实现方式是最为经典的，也是运营的最多的，网上也有很多的原生或jq插件，本文这里也用原生js重新封装了一个类库，方便调用，效果如图</p>
<p><img src="http://a1.qpic.cn/psb?/V12Zwqs81gGyHH/vdrrx8fBUCRZiDYzjwgn5ESJt8dTew8UMVqRawpRrAg!/b/dHcBAAAAAAAA&amp;bo=GwN2AgAAAAAFAE8!&amp;rf=viewer_4" alt="Mou icon"></p>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>瀑布流的实现思路其实很简单，如下:</p>
<p>1.获取元素容器的总宽度allWith, 每一个瀑布流元素的列宽度 itemWidth(如果大于allwidth,会有一个默认值替代)</p>
<p>2.计算当前容器可以显示的列数 column Math.floor(allwidth/itemWidth) 向下取整</p>
<p>3.添加一个元素前，计算每一列当前的高度，寻找当前高度最小的列，然后根据列的序号k，确定item的left和top，lef=k*itemWidth top=当前列的高度，然后当前列插入这个元素，当前列的高度加上这个元素的高度</p>
<p>4.所有元素插入完毕后，容器的高度会调整为最大列的高度</p>
<p>5.初始化就是先读取页面的所有元素，然后一个一个插入，加载更多就是在已有的元素基础上，插入新的元素计算</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/14/wqq/" class="archive-article-date">
  	<time datetime="2016-11-14T09:22:23.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-14</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-wqq" data-title="网页瀑布流效果实现的几种方式" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wangqianqian11"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-qq" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/12/qq/">使用 Gulp 构建 AngularJS / Jade 项目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我所经历的大部分项目，并不是纯粹的前端项目，相关的前端文件，都是使用 Express 来处理，除了 Jade 文件之外的，全部放在 Express 静态文件目录public中，Bower 也配置为将依赖包直接安装到public/lib目录，然后直接使用原路径在 HTML 中引用对应的 JavaScript / CSS 文件，经常是一个页面加载几十个静态资源。<br>上周在做一个 App 项目的商户端，对应的 API 已经完成，只是用 AngularJS 来实现一个前端 Web 页面，其中的 HTML 使用了 Jade 来完成。由于是一个完全的前端项目，终于决定尝试用 Gulp 来进行构建。整体的需求如下：</p>
<p>使用 Bower 管理前端依赖<br>需要将 Jade 文件编码成 HTML，并按照 Angular New Router 中的 Components 来组织目录结构<br>将 CSS / JavaScript 文件组装为单个文件<br>图片和字体等静态资源存放到对应目录<br>使用 Gulp 创建一个调试用的服务器，并能够修改文件后自动重载浏览器页面</p>
<h2 id="项目的目录与文件结构"><a href="#项目的目录与文件结构" class="headerlink" title="项目的目录与文件结构"></a>项目的目录与文件结构</h2><p>整体文件夹结构如下：</p>
<pre><code>├── app
│   ├── controllers // AngularJS 控制器
│   │   └── home.js
│   ├── modules // AngularJS 模块
│   │   └── app.js
│   ├── services // AngularJS 服务
│   │   └── city.client.service.js
│   └── views // Jade 文件
│       ├── index.jade
│       └── _partial
│           └── home.jade
├── bower.json
├── config.js
├── gulpfile.js
├── package.json
├── README.md
└── static
├── css
│   └── style.css
└── images
    ├── avatar.png
    └── logo.gif
</code></pre><p>另外还有个public目录，作为发布目录，提供给 Web 服务器对外发布。所有需要在浏览器使用的文件，最后使用都要生成或者复制到public中。</p>
<h2 id="使用-Bower-管理前端依赖"><a href="#使用-Bower-管理前端依赖" class="headerlink" title="使用 Bower 管理前端依赖"></a>使用 Bower 管理前端依赖</h2><p>悲剧，在我定这篇文章的大纲的时候， Bower 还在更新，结果没两天就宣布不再开发了。</p>
<p>Bower 之所以在以前统治着前端包管理领域，原因在于它的扁平化包管理， NPM 中每个模块都有独立的属于各自的目录，来存储对应的依赖包，虽然会占用比较多的磁盘，但却可以防止模块版本不同而造成的依赖问题。 Bower 本身并不直接决定应用的包依赖，它将模块的依赖同模块本身一样安装。</p>
<p>自从 NPM 成立专门的公司来运营以后，已经致力于将自己从Node Package Manager提升为JavaScript Package Manager。所以也开始像 Bower 来组织模块的依赖—— Bower 存在的理由又少了一个。</p>
<p>这两天，网上正在嘲笑bower –save并不会把当前已经安装的依赖存储到bower.json，不过我怀疑他们没有看到过 NPM 3.3.x 是怎么处理依赖的，npm –save后的package.json估计会相当的不堪入目吧。</p>
<h2 id="Jade-模板文件转换为-HTML-文件"><a href="#Jade-模板文件转换为-HTML-文件" class="headerlink" title="Jade 模板文件转换为 HTML 文件"></a>Jade 模板文件转换为 HTML 文件</h2><p>以前 Jade 文件是使用 Express 的view engine来转译，在专门的路由文件中，一一按照 Angular New Router 的 Components 标准来进行解析。使用 Gulp 转换也是类似，借助gulp-jade模块，设置gulp.src为 jade 文件路径，gulp.dest为转换后的 HTML 文件路径，为了方便，将需要转换的 jade 文件和对应的路径组成一个数组，再在gulp.task中对数据进行遍历，并执行转换。</p>
<pre><code>var gulp = require(&apos;gulp&apos;);
var jade = require(&apos;gulp-jade&apos;);

var jadeFiles = [
{src: &apos;./app/views/index.jade&apos;, dest: &apos;./public/&apos;},
{src: &apos;./app/views/_partial/home.jade&apos;, dest: &apos;./public/components/home/&apos;}
];

gulp.task(&apos;jade&apos;, function(){
    jadeFiles.forEach(function(jf){
    if(!jf.src || !jf.dest) return;
    gulp.src(jf.src)
      .pipe(jade({petty: true}))
      .pipe(gulp.dest(jf.dest));
      });
});
</code></pre><h2 id="将-JavaScript-CSS-文件组装为单个文件"><a href="#将-JavaScript-CSS-文件组装为单个文件" class="headerlink" title="将 JavaScript / CSS 文件组装为单个文件"></a>将 JavaScript / CSS 文件组装为单个文件</h2><p>对于遵循 AngularJS 模块化设计的前端应用， JavaScript 文件那必然是相当多，再加上使用一些扩展，就算是中小型项目，超过 70 个以上那也是相当常见，看 Chrome 开发工具中的 Network 页那可以部是相当精彩，</p>
<p>如果只是将多个 JavaScript 和 CSS 文件合为一个，使用gulp-concat模块即可，压缩 JavaScript 文件，可以再加一个gulp-uglify模块，压缩 CSS 文件，可以使用gulp-minify-css模块。gulp.src支持使用数组的方式来指定要处理的文件列表。</p>
<pre><code>var gulp = require(&apos;gulp&apos;);
var concat = require(&apos;gulp-concat&apos;);
var uglify = require(&apos;gulp-uglify&apos;);
var minifyCss = require(&apos;gulp-minify-css&apos;);
var jsFiles = [
&apos;./bower_components/jquery/dist/jquery.js&apos;, 
&apos;./bower_components/bootstrap/dist/js/bootstrap.min.js&apos;, 
&apos;,/bower_components/PACE/pace.min.js&apos;, 
&apos;./bower_components/angular/angular.js&apos;, 
&apos;./bower_components/angular-new-router/dist/router.es5.js&apos;, 
&apos;./bower_components/at-table/dist/angular-table.js&apos;, 
&apos;./app/modules/businessApp.js&apos;, 
&apos;./app/controllers/home.js&apos;
];
var cssFiles = [
&apos;./bower_components/bootstrap/dist/css/bootstrap.min.css&apos;, 
&apos;./bower_components/font-awesome/css/font-awesome.min.css&apos;, 
&apos;./bower_components/PACE/themes/blue/pace-theme-loading-bar.css&apos;, 
&apos;./static/css/start.css&apos;
];
</code></pre><p>// 在这两个 <code>min</code> 任务之外，还有两个不带 <code>min</code> 的任务，区别在于不对文件压缩<br>gulp.task(‘scripts_min’, function(){<br>  return gulp.src(jsFiles)<br>    .pipe(concat(‘all.js’)) // 合并 JavaScript ，并设置合并后的文件名<br>    .pipe(uglify()) // 执行 JavaScript 压缩<br>    .pipe(gulp.dest(‘./public/js’));<br>});<br>gulp.task(‘stylesheets_min’, function(){<br>  return gulp.src(cssFiles)<br>    .pipe(concat(‘all.css’)) // 合并 CSS ，并设置合并后的文件名<br>    .pipe(minifyCss()) // 执行 CSS 压缩<br>    .pipe(gulp.dest(‘./public/stylesheet’));<br>});</p>
<h2 id="管理图片字体等静态资源"><a href="#管理图片字体等静态资源" class="headerlink" title="管理图片字体等静态资源"></a>管理图片字体等静态资源</h2><p>对于图片、字体等文件，只是需要使用 Gulp 自带的gulp.src和gulp.dest来复制到 Web 目录即可。除了这些静态文件，有些文件可能也需要单独处理，比如 JavaScript 中的一些配置项文件，另外，如果使用加载状态提示模块，这个也是需要优秀加载的。顺便安利一下 PACE ，它是个使用相当方便的加载提示模块。</p>
<pre><code>gulp.task(&apos;pace&apos;, function(){
  // copy pace.js to js folder
  return gulp.src(&apos;./bower_components/PACE/pace.min.js&apos;)
    .pipe(gulp.dest(&apos;./public/js&apos;));
});
</code></pre><p>其它需要直接复制的文件，也都是类似方法处理。</p>
<p>##使用 Gulp 来创建文件修改后浏览器自动刷新的 Web 服务器<br>如果想要文件修改后，浏览器自动刷新，需要做两方面的工作：</p>
<p>监控 JavaScript / Jade / CSS 文件，修改后重新转换或者压缩<br>监控 JavaScript / Jade / CSS 文件，修改后刷新浏览器<br>对于第一个，使用gulp-watch模块来监视文件，并执行对应的 Task ，对于第二个，可以使用gulp-webserver模块，它可以创建一个 Web 服务器，并且在浏览器和服务器之间创建 Socket.IO 长链接，一旦有文件修改，便通过长链接通知浏览器刷新页面。</p>
<pre><code>var gulp = require(&apos;gulp&apos;);
var webserver = require(&apos;gulp-webserver&apos;);

gulp.task(&apos;watch&apos;, function(){
  // 不同的文件个性，需要执行不同的任务来处理
  gulp.watch([&apos;app/views/*&apos;, &apos;app/views/_partial/*&apos;],     [&apos;jade&apos;]);
  gulp.watch([&apos;bower_components/*&apos;], [&apos;scripts&apos;,     &apos;stylesheets&apos;]);
  gulp.watch([&apos;static/css/*&apos;], [&apos;stylesheets&apos;]);
  gulp.watch([&apos;app/controllers/*&apos;, &apos;app/modules/*&apos;,     &apos;app/services/*&apos;], [&apos;scripts&apos;]);
});

gulp.task(&apos;webserver&apos;, function(){
  gulp.src(&apos;./public/&apos;)
    .pipe(webserver({
      host: &apos;0.0.0.0&apos;,
      livereload: true,
      fallback: &apos;index.html&apos;
    }));
});
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/12/qq/" class="archive-article-date">
  	<time datetime="2016-11-12T07:51:52.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-12</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-qq" data-title="使用 Gulp 构建 AngularJS / Jade 项目" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wangqianqian11"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-xiangyingshi" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/08/xiangyingshi/">响应式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>响应式设计，用一句话概括就是针对任意设备对网页内容进行完美布局的一种显示机制。利用HTML5和CSS3就更加如虎添翼。</p>
<p>HTML5强调简化标签，例如文档类型声明，在HTML5中，仅用&lt;!DOCTYPE html&gt;即可，链接外部脚本、样式文件，也更加宽松，无需type属性，如下：</p>
<pre><code>&lt;script src=&apos;Monkey.js&apos;&gt;&lt;/script&gt;
</code></pre><p>代替–&gt;</p>
<pre><code>&lt;script src=&apos;Monkey.js&apos; type=&apos;text/javascript&apos;&gt;&lt;/script&gt;
</code></pre><p>同时，HTML5新增了语义化标签元素，易读和利于SEO，如下：</p>
<p><code>&lt;section&gt;</code>元素用来定义文档或应用程序中的区域。</p>
<p><code>&lt;nav&gt;</code>元素用来定义文档的主导航区域</p>
<p><code>&lt;article&gt;</code>元素用来包裹独立的内容片段。</p>
<p><code>&lt;aside&gt;</code>元素用来表示与页面主内容松散相关内容。</p>
<p><code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;address&gt;</code>、<code>&lt;hgroup&gt;</code></p>
<p>而CSS3，根据其新特性，则可代替JavaScript，实现一些动画效果，轻量级且易于维护。</p>
<p>响应式设计结合了CSS3媒体查询、流式布局和弹性图片技术，下面就一起来看看。</p>
<h2 id="二、CSS3媒体查询"><a href="#二、CSS3媒体查询" class="headerlink" title="二、CSS3媒体查询"></a>二、CSS3媒体查询</h2><p>CSS3媒体查询，就是由媒体类型（screen和print）和一个或多个检测媒体特性的条件表达式组成，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。</p>
<p>媒体查询中常用媒体特性，如下：</p>
<p>–width：视口宽度；</p>
<p>–height：视口高度；</p>
<p>–device-width：设备屏幕宽度；</p>
<p>–device-height：设备屏幕高度；</p>
<p>–orientation：检查设备处于横向还是纵向；</p>
<p>–aspect-ratio：基于视口宽度和高度比；</p>
<p>以上特性，都可使用min和max前缀来创建一个查询范围。</p>
<p>举例，当屏幕中视口宽度小于960像素时，如下CSS代码生效：</p>
<pre><code>/*CSS样式表中使用媒体查询*/
@media screen and (max-width: 960px){
    body{
        background-color:grey;
        …
    }
}
/*CSS外部链接中使用媒体查询*/
&lt;link rel=”stylesheet” media=”screen and (max-width:960px)”     href=”monkey.css”/&gt;
</code></pre><p>PS：为了阻止移动浏览器自动调整页面大小，我们还得使用meta，定义如下：</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-    scale=1.0&quot;/&gt;
</code></pre><p>content里的内容就是告诉浏览器页面的宽度应该等于设备宽度。</p>
<h2 id="三、流式布局"><a href="#三、流式布局" class="headerlink" title="三、流式布局"></a>三、流式布局</h2><p>媒体查询，威力无穷，但是它的局限性也很明显，在媒体查询设置的不同断点，CSS样式只会从一组突变到另一组，样式之间没有任何平滑渐变。</p>
<p>因此，我们引入“流式布局”来弥补媒体查询的短板。</p>
<p>流式布局，又叫百分比布局，顾名思义就是使用百分比来代替固定像素的宽度，两者之间怎么转化呢？</p>
<p>公式如下：</p>
<pre><code>目标元素宽度 / 上下文元素宽度 = 百分比宽度
</code></pre><p>例如，现有html代码如下：</p>
<pre><code> &lt;body&gt;
    &lt;div id=&quot;wrapper&quot;&gt;
        &lt;header&gt;
            &lt;nav&gt;
                &lt;ul&gt;
                    &lt;li&gt;navigation1&lt;/li&gt;
                    &lt;li&gt;navigation2&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/nav&gt;
        &lt;/header&gt; 
    &lt;/div&gt;        
&lt;/body&gt;
</code></pre><p>固定像素样式如下</p>
<pre><code>* {
      margin: 0;
    padding: 0;
}
#wrapper {
    margin: 0 auto;
    width: 960px;
    background: grey;
}
header {
    margin-right: 10px;
    margin-left: 10px;
    width: 940px;
}
nav {
    padding-top: 20px;
    padding-bottom: 20px;
    width: 940px;
}
nav ul li {
    display: inline-block;
    list-style-type: none;
}
</code></pre><p>现在，我们将样式中的宽度、水平方向的内外边距，利用上面公式转换成百分比，如下：</p>
<p>PS：假设我们以1000像素的视口为基准。</p>
<pre><code>/*目标元素宽度 / 上下文元素宽度 = 百分比宽度*/
* {
    margin: 0;
    padding: 0;
}
#wrapper {
    margin: 0 auto;
    width: 96%;/* 960 / 1000 = 96% */
    background: grey;
}
header {
    margin-right: 1.041667%;/* 10 / 960 = 1.041667% */
    margin-left: 1.041667%;/* 10 / 960 = 1.041667% */
    width: 97.916667%;/* 940 / 960 = 97.916667% */
}
nav {
    padding-top: 20px;
    padding-bottom: 20px;
    width: 100%;/* 940 / 940 = 100% */
}
nav ul li {
    display: inline-block;
    list-style-type: none;
}
</code></pre><p>在上述CSS样式中，我们换算百分比，之所以保留如此多位数，是为了更加精确。</p>
<p>此外，我们还可以将像素级文字，转换成相对单位—em。上述转换公式同样适用于将文字的像素单位转换为相对单位。</p>
<p>不过，值得注意的是，现代浏览器的默认文字大小都是16像素（显示声明除外），因此一开始给body标签应用如下任何一条规则所产生的效果都是一样的：</p>
<pre><code>font-size: 100%;

font-size: 16px;

font-size: 1em;
</code></pre><h2 id="四、弹性图片"><a href="#四、弹性图片" class="headerlink" title="四、弹性图片"></a>四、弹性图片</h2><p>在现代浏览器中要实现图片随着流动布局相应缩放非常简单，只需在CSS中作如下声明，即可：</p>
<pre><code>img {
    max-width: 100%;
}
</code></pre><p>这样就可以使图片自动缩放到与其容器100%匹配。更进一步，可以将同样的样式应用到其他多媒体标签上，使其也可以自动缩放，如下：</p>
<pre><code>img, object, video, embed {
    max-width: 100%;
}
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/08/xiangyingshi/" class="archive-article-date">
  	<time datetime="2016-10-08T08:23:11.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-08</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-xiangyingshi" data-title="响应式" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wangqianqian11"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/30/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/09/30/hello-world/" class="archive-article-date">
  	<time datetime="2016-09-30T01:23:59.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-09-30</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-hello-world" data-title="Hello World" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wangqianqian11"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-fenxiang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/15/fenxiang/">web前端开发必备网站</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>作为前端开发，那手头上必然要有几个有用的网站，以免碰到问题或者需要了解的时候没有地方查询。下面推荐几个我比较常用的网站。</p>
<h2 id="大前端"><a href="#大前端" class="headerlink" title="大前端"></a>大前端</h2><p>以前端开发为主的综合性博客，有关前端开发的相关知识在这里介绍的很全面。</p>
<h2 id="Css3Maker"><a href="#Css3Maker" class="headerlink" title="Css3Maker"></a><a href="http://www.css3maker.com/" target="_blank" rel="external">Css3Maker</a></h2><p>是一款css3生成器，强大，更全面。</p>
<h2 id="HTML5中文网"><a href="#HTML5中文网" class="headerlink" title="HTML5中文网"></a><a href="http://www.html5cn.org/" target="_blank" rel="external">HTML5中文网</a></h2><p>html5中文网，有关html5教程在这里很全面。</p>
<h2 id="w3cplus"><a href="#w3cplus" class="headerlink" title="w3cplus"></a><a href="http://www.w3cplus.com/" target="_blank" rel="external">w3cplus</a></h2><p>记述前端那些事引领web前沿打造精品css3教程。</p>
<h2 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a><a href="http://www.css88.com/" target="_blank" rel="external">前端开发</a></h2><p>专注前端开发，关注用户体验，很全面的网站</p>
<h2 id="前端观察"><a href="#前端观察" class="headerlink" title="前端观察"></a><a href="https://www.qianduan.net/" target="_blank" rel="external">前端观察</a></h2><p>专注于网站前端设计与前端开发。</p>
<h2 id="慕课网"><a href="#慕课网" class="headerlink" title="慕课网"></a><a href="http://www.imooc.com/" target="_blank" rel="external">慕课网</a></h2><p>学习编程最简单的免费平台。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/08/15/fenxiang/" class="archive-article-date">
  	<time datetime="2016-08-15T03:34:15.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-08-15</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-fenxiang" data-title="web前端开发必备网站" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wangqianqian11"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
    <article id="post-bibao" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/bibao/">js闭包的理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.有些文章认为闭包必须要返回嵌套函数中里面用到外面函数局部变量的方法才叫闭包,有两个条件:1)、函数嵌套，内部函数要用到外部函数的局部变量 2）、内部函数必须返回</p>
<p>2.有些文章认为只要函数嵌套内部函数用到了外部局部变量就是闭包，不要返回内部函数 </p>
<p>我们先看看闭包的定义到底是什么,然后在来分析我在学习js的时候不同阶段对闭包的误解。在高级程序设计中对闭包定义是这样的：“闭包是指有权限访问另一个函数作用域中的变量的函数。“这里没有提到这个函数必须要return出来，我们在看看语言精粹中对闭包的定义是用一段很误导人的代码例子来解释闭包：</p>
<pre><code>    var quo=function(status){
      return{
            get_status:function(){
              return status;
           }
      }
    }

var myQuo=quo(&quot;amazed&quot;);
document.writeln(myQuo.get_status());
</code></pre><p>“即使quo返回了,但get_status方法仍然享有访问quo对象的status属性的特权,get_status方法并不是访问该参数的一个副本,它访问的是该参数本身,只是可能的,因为该函数可以访问它被创建时所处的上下文环境,这被称为闭包. “</p>
<p>   这是很多解释闭包的文章最常用的解释案例,所以导致新手第一次看这种解释产生一个误导,说必须要return这个函数,但我们看看《javascript语言精粹》这段解释中最后强调的是该函数可以访问被创建时所处的上下文环境，强调的是访问外部函数的局部变量，</p>
<p>而用这个例子是因为这个例子是闭包的更为复杂的应用，因为你在函数嵌套中，内部函数的运行只能在外部函数中执行，要在全局变量中运行不了，如果我们要在全局运行一个比较容易理解的方法是：</p>
<pre><code> var get_status;
        var quo=function(status){
            get_status=function(){
                return status;
            }
        }

quo(&quot;amazed&quot;);

document.writeln( get_status());
</code></pre><p>那这种是不是闭包呢？对上面代码进行优化利用js 可以return函数代码简化了很多。所以在我的理解只要调用了外部函数变量的函数都是闭包，而之所以对闭包的介绍都用那个案例是因为那个算是闭包的经典复杂的应用所以基本介绍闭包的都会介绍那个案例，这样反而误导了刚学习闭包的同学必须要return出去，下面我在说说我理解闭包踩过的坑。</p>
<p>刚开始我对闭包理解就是匿名自执行函数，匿名自执行函数如下代码：</p>
<pre><code>(function(){})()
//or
var dem=(function(){}())
</code></pre><p>这个匿名自执行用到最多的当然是jQuery里面：</p>
<pre><code>(function ($) {

       })(jQuery)
</code></pre><p>在jQuery插件中经常会看到这种写法,这样写的目的是为了$变量有可能会在网页中被定义成其他值,而为了避免$符号的冲突而将jQuery这个对象赋值成局部$变量。这样就不会影响全局$。</p>
<p>还有一种用法是：</p>
<pre><code>var a = [];
   for (var i = 0; i &lt; 10; i++) {
       a[i] = function () {
           console.log(i);
       };
   }
   a[6]();
</code></pre><p>因为js没有块作用域所以导致i其实是全局变量，所以a中的所以方法里面的i都是10，解决这个问题可以用es6 中let，但目前有些浏览器不支持es6,谷歌已经支持let关键字了，现在做法是用es6的写法通过node插件转换成es5的写法，还用一种解决方法是：</p>
<pre><code>var a = [];
  for (var i = 0; i &lt; 10; i++) {
      (function(i){
          a[i] = function () {
              console.log(i);
          };
      })(i)
  }
  a[6]();      
</code></pre><p>闭包在实际项目中应用说白了就是一个函数中要频繁操作一些变量，但这个变量在函数中定义在函数每次运行的时候都要重新声明分配内存空间一来麻烦二来感觉消耗内存（用过C#和java的都应该很熟悉垃圾处理机制，js的垃圾处理机制类似不多详细介绍了）但设置成全局变量又会污染全局变量，在js性能优化中提到尽量不要污染全局变量，自然外面套成函数的方式就出来了也就是闭包咯，但又要保证内部函数的运行灵活性不能限制在外层闭包的作用域，return这个函数的方式就出来了，外层函数不想用变量存储而且还要单独运行一次，那么匿名自执行的的方式出来了，ok需求演变导致最后的组合书写方式。在这里在讲讲闭包的缺点，闭包一个缺点是让调用的变量会一直存储在内存得不到释放，这个缺点在实际项目需求中有不同的解决方法：</p>
<pre><code>var serial_maker=function () {
       var prefix=&apos;&apos;;
       var seq=0;
       return{
           set_prefix:function (p) {
               prefix=new String(p)
           },
           set_seq:function (s) {
               seq=s;
           },
           gensym:function () {
               var result=prefix+seq;
               seq+=1;
               return result;
           }
       }
   }
   var seqer=serial_maker();
   seqer,set_prefix(&apos;Q&apos;);
   seqer.set_seq(1000);
   var unique=seqer.gensym(); //unique是&quot;Q1000&quot;
</code></pre><p>这是也很常见的闭包，用意就是不想把prefix和seq声明为全局变量，而污染全局变量，在变量生命周期的角度其实和全局变量是一样的，prefix和seq会一直存在内存中直到页面关闭，javascript高级程序设计中说变量会在函数执行完毕后就进行释放，而全局变量会一直在内存中直到浏览器关闭，书还提到在浏览器关闭的时候要将用到的dom对象的变量赋值null，因为浏览器貌似不能释放dom对象，这点我有点模糊记不太清楚了，我复习javascript高级程序设计的时候看到了在单独写一遍随便。解决闭包的这个缺点只需在外面加一层匿名自执行函数就可以了</p>
<pre><code>(function () {
      var serial_maker=function () {
          var prefix=&apos;&apos;;
          var seq=0;
          return{
              set_prefix:function (p) {
                  prefix=new String(p)
              },
              set_seq:function (s) {
                  seq=s;
              },
              gensym:function () {
                  var result=prefix+seq;
                  seq+=1;
                  return result;
              }
          }
      }
  })();
</code></pre><p>闭包中用到的变量的生声明周期其实是跟着调用这个函数的上一函数的生命周期的，这个例子的中的prefix和seq是在匿名函数执行后就被释放了。这也是在平时写js时候尽量在外面套一层匿名自执行一来不会污染全局变量，二来在匿名函数执行完了里面的的变量就释放掉了，相对在性能优化上做了一点点贡献和优化吧！</p>
<p>第二场景：同样在事件绑定上也可以用匿名闭包，性能确定就存在了，你在设置全局变量和闭包其实一个内存占用量。不可避免的。</p>
<p>第三场景：柯里化</p>
<p>柯里化就是将函数的参数传递给另一个函数操作,一般用到柯里化是在调用ajax成功之后将数据绑到到页面上时候用到,但随着promise的出现,其实柯里化用的很少了。下面是一个更为复杂的应用:</p>
<pre><code>Function.prototype.curry=function () {
     var slice=Array.prototype.slice,
             args=slice.apply(arguments),//因为arguments不是真正的数组,只是类似数组的一个对象,所以这里要将arguments转换为数组
             that=this;
     debugger;
     return function () {
         return that.apply(null,args.concat(slice.apply(arguments)))
     }
 };
 var add=function () {
     var total=0;
    for(var i=0;i&lt;arguments.length;i++){
        total+=arguments[i];
    }
    return total;
 };
   var add1=add.curry(1);
   document.writeln(add1(6));//7
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/07/06/bibao/" class="archive-article-date">
  	<time datetime="2016-07-06T01:32:26.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-07-06</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>








<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-bibao" data-title="js闭包的理解" data-url="undefined"></div>

<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"wangqianqian11"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

  
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 七月
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>